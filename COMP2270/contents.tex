\documentclass[a4paper]{article}
    \usepackage[margin=0in]{geometry}
    \usepackage{amssymb}
    \usepackage{multicol}

    \begin{document}
    \begin{multicols}{2}
        \scriptsize
        \noindent\underline{\textbf{Proof techniques}}: construction, contradiction, counterexample, case enumeration, induction, pigeonhole principle, proving cardinality, diagonalization\\
        \underline{\textbf{Languages, Strings}}\\
        \textbf{Alphabet}: finite set of symbols\\
        \textbf{String}: finite sequence of symbols from alphabet\\
        \textbf{Replication}: $w^0 = \varepsilon, w^{i+1} = w^i w$\\
        \textbf{Reverse}: $w^R = w = \varepsilon$ if $|w| = 0$, else $\exists a \in \Sigma$ and $\exists u \in \Sigma ^*$ such that $w = ua$, then define $w^R = {au}^R$\\
        \boldmath${(wx)}^R = x^r w^r$\unboldmath: induction on $|x|$, base case $|x| = 0$ so $x = \varepsilon$, consider any string x where $|x| = n+1$, then $x = ua$ for some character $a$ and $|u| = n$, so ${(wx)}^R = {(w(ua))}^R = {(wu)a}^R = a{(wu)}^R = a(u^R w^R) = (a u^R) w^R = {(ua)}^R w^R = x^R w^R$\\
        \textbf{Language}: set of strings (finite/infinite) from alphabet, uncountably infinite number of these (power set of $\Sigma ^*$)\\
        \boldmath$\Sigma ^*$\unboldmath: countably infinite with non-empty alphabet, enumerate with lexicographic order\\
        \boldmath$L_1 L_2$\unboldmath: $\{ w \in \Sigma ^* : \exists s \in L_1 (\exists t \in L_2 (w = st)) \}$\\
        \boldmath$L^*$\unboldmath: $\{ \varepsilon \} \cup \{ w \in \Sigma ^* : \exists k \geq 1 (\exists w_1, w_2, \ldots w_k \in L (w = w_1 w_2 \ldots w_k)) \}$ or $L^0 \cup L^1 \cup L^2 \cup \ldots$\\
        \boldmath$L^+$\unboldmath: $L L^*$ or $L^* - \{\varepsilon\}$ iff $\varepsilon \notin L$ or $L^0 \cup L^1 \cup L^2 \cup \ldots$\\
        \boldmath${(L_1 L_2)}^R = L_2^R L_1^R$\unboldmath: $\forall x (\forall y ({(xy)}^R = y^R x^R))$ from before, then ${(L_1 L_2)}^R = \{ {(xy)}^R : x \in L_1$ and $y \in L_2 \} = \{ y^R x^R : x \in L_1$ and $y \in L_2 \} = L_2^R L_1^R$\\
        \textbf{Decision problem}: problem to which answer is yes/no or true/false\\
        \textbf{Decision procedure}: answers decision problem\\
        \textbf{Machine power hierarchy}: FSM (regular), PDA (context-free), TM (semi-decidable \& decidable)\\
        \textbf{Rule of least power}: use least powerful language suitable for expressing info, constraints or programs on WWW\\
        \boldmath$firstchars(L)$\unboldmath: $\{ w : \exists y \in L (y = cx \wedge c \in \Sigma _L \wedge x \in \Sigma _L^* \wedge w \in c^*) \}$, closed under FIN but not INF (since result is first character $^*$)\\
        \boldmath$chop(L)$\unboldmath: $\{ w : \exists x \in L (x = x_1 c x_2, x_1 \in \Sigma_L^*, x_2 \in \Sigma_L^*, c \in \Sigma_L, |x_1| = |x_2|$, and $w = x_1 x_2)$\\, language where all strings have exact middle character removed, must have had odd length to begin with, closed under FIN but not INF (can get empty set if never odd length)\\
        \textbf{Extra}: to describe language with at least 2 different substrings of length 2 $L = \{ w \in {\{a,b\}}^* : \exists x, y (x \neq y \wedge |x| = 2 \wedge |y| = 2 \wedge Substr(x,w) \wedge Substr(y,w)) \}$\\
        \underline{\textbf{Finite State Machines}}\\
        \textbf{DFSM Quintuple}: $M = (K, \Sigma, \delta, s, A)$, $K$ = finite set of states, $\Sigma$ = alphabet, $\delta$ = transition function from $(K \times \Sigma)$ to $K$, $s \in K$ = initial state, $A \subseteq K$ = set of accepting states\\
        \textbf{Configuration}: element of $K \times \Sigma^*$, current state and remaining input\\
        \textbf{Yields relation}: $|-_M$, relates 2 configurations if $M$ can move from the first to the second in 1 step, $|-_M^*$ for 0 or more\\
        \textbf{Computation}: finite sequence of configurations for some $n \geq 0$ such that $C_0$ is an initial configuration, $C_n$ is of the form $(q, \varepsilon)$ for some state $q \in K_M$ and $C_0 |-_M C_1 |-_M C_2 |-_M \ldots |-_M C_n$\\
        \textbf{DFSM will halt in $|w|$ steps}: execute computation from $C_0$ to $C_n$, each step will consume one character, so $n = |w|$, $C_n$ is either accepting or rejecting configuration, so will halt after $|w|$ steps\\
        \textbf{Parity}: odd if number of 1 is odd for binary string\\
        \boldmath$MinDFSM(M: DFSM)$\unboldmath:\\
        Initialise classes with an accepting class \& non-accepting class\\
        For each class with more than 1 state\\
        For each state and character check which class it goes to\\
        If behaviour differs between states split them\\
        End for\\
        End for\\
        Go through all the classes again until no splitting happens\\
        Each class becomes its own state, transitions already defined above\\
        \textbf{Number of states $\geq$ equivalence classes in L}: suppose it is less than equivalence classes, then by pigeonhole principle there must be at least 1 state that contains strings from 2 equivalence classes, but then future behaviour on these two strings will be identical, which is not consistent with the fact that they are in different equivalence classes\\
        \textbf{NDFSM Quintuple}: replace $\delta$ with $\Delta$, transition relation, finite subset of $(K \times (\Sigma \cup \{\varepsilon\})) \times K$\\
        \textbf{NDFSM vs DFSM}: can enter configuration with input symbols left but no move available (halt without accepting), can enter configuration from which 2 or more competing transitions available ($\varepsilon$-transition, more than 1 transition for single input character)\\
        \boldmath$eps(q)$\unboldmath: $\{ p \in K : (q,w) |-^*_M (p,w) \}$, closure of $\{q\}$ under relation $\{ (p,r)$: there is a transition $(p, \varepsilon, r) \in \Delta \}$, to calculate initialise $result = \{q\}$, add all transitions $(p, \varepsilon, r) \in \Delta$ where $p \in result, r \notin result$ to $result$, then return $result$\\
        \boldmath$ndfsmtodfsm(M: NDFSM)$\unboldmath:\\
        Compute $eps(q)$ for each state $q$, $s' = eps(s)$ (initial state)\\
        Set $active\mbox{-}states = \{s'\}$ (set of set of states) and $\delta' = \varnothing$\\
        While $\exists Q \in active\mbox{-}states$ for which $\delta'$ has not been computed //computing $\delta'$\\
        For each $c \in \Sigma_M$\\
        Set $new\mbox{-}state = \varnothing$\\
        For each state $q \in Q$\\
        For each state $p : (q, c, p) \in \Delta$\\
        Set $new\mbox{-}state = new\mbox{-}state \cup eps(p)$\\
        End for\\
        Add $(Q, c, new\mbox{-}state)$ to $\delta'$, if $new\mbox{-}state \notin active\mbox{-}states$ insert it\\
        End for\\
        End for\\
        End while\\
        Set $K' = active\mbox{-}states$ and $A' = \{ A \in K' : Q \cap A \neq \varnothing \}$\\
        \textbf{Extra}: when making FSM may start with complement\\
        \underline{\textbf{Regular expressions}}:\\
        \textbf{Allowable}: $\varnothing, \varepsilon$, every element of $\Sigma$, if $\alpha, \beta$ are regex then so are $\alpha\beta, \alpha\cup\beta, \alpha^*, \alpha^+, (\alpha)$, no actual need for rules for $\varepsilon$ and $\alpha^*$\\
        \textbf{Order of operations}: Kleene star, concatenation, union (high to low)\\
        \textbf{FSM \& Regex equivalence}: can create FSM to accept regex (do so for each rule), algorithm exists for other way\\
        \boldmath$fsmtoregexheuristic(M: FSM)$\unboldmath: remove unreachable states, if no accepting states return $\varnothing$, if start state part of loop create new start state $s$ \& connect $s$ to original start via $\varepsilon$-transition, if multiple accepting states create new accepting state \& connect old ones to new with $\varepsilon$-transition, if only 1 state return $\varepsilon$, rip out all states other than start \& accept, return regex\\
        \boldmath$fsmtoregex(M: FSM)$\unboldmath: $buildregex(standardize(M))$\\
        \boldmath$standardize(M: FSM)$\unboldmath: remove unreachable states, create start \& accepting if needed (from heuristic), if multiple transitions exist between 2 states collapse, create any missing transitions with $\varnothing$\\
        \boldmath$buildregex(M: FSM)$\unboldmath:\\
        If no accepting return $\varnothing$, if only 1 state return $\varepsilon$\\
        While states exist that are not start or accepting\\
        Select some state $rip$\\
        For every transition from $p$ to $q$\\
        If both $p$ \& $q$ are not $rip$ compute new transition ($R'(p,q) = R(p,q) \cup R(p,rip) {R(rip, rip)}^* R(rip, q$), either direct or via $rip$), then remove $rip$\\
        End for\\
        End while\\
        Return final regex\\
        \underline{\textbf{Regular grammar}}:\\
        \textbf{Quadruple}: $(V, \Sigma, R, S)$, $V$ = rule alphabet, both nonterminals \& terminals, $\Sigma$ = terminals, $\subseteq V$, $R$ = finite set of rules, LHS single nonterminal, RHS is $\varepsilon$, single terminal or single terminal + single nonterminal, $S$ = nonterminal\\
        \textbf{Regular Languages \& Grammar equivalence}: construction, both ways\\
        \boldmath$grammartofsm(G)$\unboldmath: create separate state for each nonterminal, start state is $S$, if rule exist with single terminal RHS create new state labeled \#, for each rule $X \to aY$ create transition from $X$ to $Y$ labeled $a$, if $X \to a$ go to \#, if $X \to \varepsilon$ mark as accept, mark state \# as accept, if undefined (state, input) pairs remaining point them to dead state \& add loops to dead state for each character\\
    \end{multicols}
    \end{document}
